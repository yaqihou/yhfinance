import numpy as np
import pandas as pd

import mplfinance as mpf

from ..ohlc_cols import Col, ColName
from ..ohlc_data import OHLCData

from ._indicators_mixin import *
from ._base import _BaseIndicator


class IndMoneyFlowIndex(_PeriodMixin, _BaseIndicator):
    """The Money Flow Index (MFI) is a technical oscillator that uses
    price and volume data for identifying overbought or oversold signals in
    an asset. It can also be used to spot divergences which warn of a trend
    change in price. The oscillator moves between 0 and 100.

    The Money Flow Index (MFI) is a technical indicator that generates
    overbought or oversold signals using both prices and volume data.

    An MFI reading above 80 is considered overbought and an MFI reading
    below 20 is considered oversold, although levels of 90 and 10 are also
    used as thresholds.

    A divergence between the indicator and price is noteworthy. For
    example, if the indicator is rising while the price is falling or flat,
    the price could start rising.

    """
    
    def __init__(
            self,
            data          : OHLCData,
            period        : int           = 14,
            price_col     : ColName       = Col.Typical
    ):
        super().__init__(data,
                         period=period,
                         price_col=price_col)


    def _calc(self) -> pd.DataFrame:

        _df = self._df[[self.tick_col]].copy()

        flows =  (self._df[self.price_col] * self._df[Col.Vol]).values
        _df[Col.Ind.MFlowI.Flow.name] = flows

        prices = self._df[self.price_col].values

        pos = 0.
        neg = 0.
        pos_vals = np.full((len(flows), ), np.nan)
        neg_vals = np.full((len(flows), ), np.nan)
        for idx, flow in enumerate(flows[1:self.period+1], 1):
            if prices[idx] > prices[idx] - 1:
                pos += flow
            else:
                neg += flow
            pos_vals[idx] = pos
            neg_vals[idx] = neg

        for idx, flow in enumerate(flows[self.period+1:], self.period+1):

            prev_idx = idx - self.period
            # Remove the contribution from out-of-window sample
            if prices[prev_idx] > prices[prev_idx-1]:
                pos -= flows[prev_idx]
            else:
                neg -= flows[prev_idx]

            # Add the contribution from newly added sample
            if prices[idx] > prices[idx-1]:
                pos += flow
            else:
                neg += flow

            pos_vals[idx] = pos
            neg_vals[idx] = neg

        with np.errstate(divide='ignore'):
            ratios = np.divide(pos_vals, neg_vals)
        _df[Col.Ind.MFlowI.Pos(self.period)] = pos_vals
        _df[Col.Ind.MFlowI.Neg(self.period)] = neg_vals
        _df[Col.Ind.MFlowI.Ratio(self.period)] = ratios
        _df[Col.Ind.MFlowI.MFI(self.period)] = 100 - (100 / (1 + ratios))

        return _df

    @property
    def values(self):
        return self._df[Col.Ind.MFlowI.MFI].values
    
    @property
    def need_new_panel_num(self) -> bool:
        return True

    def make_addplot(self, plotter_args: dict,
                     *args,
                     **kwargs) -> list[dict]:

        return [
            mpf.make_addplot(
                self.df[Col.Ind.MFlowI.MFI(self.period)],
                type='line', panel=plotter_args['new_panel_num'],
                label=Col.Ind.MFlowI.MFI(self.period)
            )
        ]


class IndOnBalanceVolume(_BaseIndicator):
    """On-balance volume (OBV) is a technical trading momentum indicator
    that uses volume flow to predict changes in stock price. Joseph
    Granville first developed the OBV metric in the 1963 book Granville's
    New Key to Stock Market Profits.

    Granville believed that volume was the key force behind markets and
    designed OBV to project when major moves in the markets would occur
    based on volume changes. In his book, he described the predictions
    generated by OBV as "a spring being wound tightly." He believed that
    when volume increases sharply without a significant change in the
    stock's price, the price will eventually jump upward or fall downward.
    """

    def _calc(self) -> pd.DataFrame:

        _df = self._df[[self.tick_col]].copy()

        volumes = self.df[Col.Vol].values
        closes_diff = np.diff(self.df[self.price_col].values)
        volume_adj = np.full_like(volumes, np.nan)
        volume_adj[1:] = np.sign(closes_diff) * volumes[1:]

        _df[Col.Ind.OBV.name] = volume_adj

        return _df

    @property
    def values(self):
        return self._df[Col.Ind.OBV.name].values
    
    @property
    def need_new_panel_num(self) -> bool:
        return True

    def make_addplot(self, plotter_args: dict,
                     *args,
                     **kwargs) -> list[dict]:

        return [
            mpf.make_addplot(
                self.df[Col.Ind.OBV],
                type='line', panel=plotter_args['new_panel_num'],
                label='On-Balance Vol'
            )
        ]


class IndAccumulationDistribution(_BaseIndicator):
    """The accumulation/distribution indicator (A/D) is a cumulative
    indicator that uses volume and price to assess whether a stock is being
    accumulated or distributed. The A/D measure seeks to identify
    divergences between the stock price and the volume flow. This provides
    insight into how strong a trend is. If the price is rising but the
    indicator is falling, then it suggests that buying or accumulation
    volume may not be enough to support the price rise and a price decline
    could be forthcoming.

    Limitation:

    - The A/D indicator does not factor in price changes from one period to
    the next, and focuses only on where the price closes within the current
    periodâ€™s range. This creates some anomalies.

    """

    def _calc(self) -> pd.DataFrame:

        _df = self._df[[self.tick_col]].copy()


        # Money Flow Multiplier = [(C - L) - (H - C)] / (H - L)
        highs = self.df[Col.High].values
        lows = self.df[Col.Low].values
        closes = self.df[Col.Close].values
        mfm =  ( (closes - lows) - (highs - closes) ) / (highs - lows)
        
        volumes = self.df[Col.Vol].values
        # Money Flow Volume = MFM * Volume
        mfv = volumes * mfm

        # A/D: AD_t+1 = AD_t + mfv_t+1
        ad = np.cumsum(mfv)

        _df[Col.Ind.AD.MFM.name] = mfm
        _df[Col.Ind.AD.MFV.name] = mfv
        _df[Col.Ind.AD.AD.name] = ad

        return _df

    @property
    def values(self):
        return self._df[Col.Ind.AD.AD.name].values
    
    @property
    def need_new_panel_num(self) -> bool:
        return True

    def make_addplot(self, plotter_args: dict,
                     *args,
                     **kwargs) -> list[dict]:

        return [
            mpf.make_addplot(
                self.df[Col.Ind.AD.AD.name],
                type='line', panel=plotter_args['new_panel_num'],
                label='Accu/Dist'
            )
        ]


class IndMarketFacilitationIndex(_BaseIndicator):
    """The Market Facilitation Index (MFI) is the creation of Bill
    Williams. The indicator endeavors to establish the effectiveness of
    price movement by computing the price movement per volume unit. This is
    accomplished by subtracting the day's low from the high and dividing
    the result by the total volume.

    As an indicator on its own the MFI is of no significant
    value. Nonetheless, if the current price candle's MFI and volume are
    compared to the previous candle's MFI and volume, the index starts to
    have some significant tradable data.

    The four possible groupings of MFI and volume were termed Green, Fade, Fake and Squat by Williams.

    MFI  Volume  Terms
    -------------------
    +    +       Green
    -    -       Fade
    +    -       Fake
    -    +       Squat
    """

    def _calc(self) -> pd.DataFrame:

        _df = self._df[[self.tick_col]].copy()

        highs = self.df[Col.High].values
        lows = self.df[Col.Low].values
        volumes = self.df[Col.Vol].values
        mfaci = (highs - lows) / volumes

        _df[Col.Ind.MFacI.MFacI.name] = mfaci

        delta_mfaci = np.full((len(volumes),), np.nan, dtype=np.float64)
        delta_mfaci[1:] = np.diff(mfaci)
        _df[Col.Ind.MFacI.DeltaMFacI.name] = delta_mfaci

        delta_vol = np.full_like(volumes, np.nan)
        delta_vol[1:] = np.diff(volumes)
        _df[Col.Ind.MFacI.DeltaVol.name] = delta_vol

        status = [pd.NA] * len(volumes)
        for idx in range(1, len(volumes)):
            if delta_mfaci[idx] >= 0 and delta_vol[idx] >= 0:
                status[idx] = 'Green'
            elif delta_mfaci[idx] >= 0 and delta_vol[idx] < 0:
                status[idx] = 'Fake'
            elif delta_mfaci[idx] < 0 and delta_vol[idx] >= 0:
                status[idx] = 'Squat'
            else:
                status[idx] = 'Fade'
        _df[Col.Ind.MFacI.Status.name] = status

        return _df

    @property
    def values(self):
        return self._df[Col.Ind.Status.name].values
    
    @property
    def need_new_panel_num(self) -> bool:
        return True

    def make_addplot(self, plotter_args: dict,
                     *args,
                     **kwargs) -> list[dict]:

        status_numerical_map = {
            'Green': 4,
            'Fake': 3,
            'Squat': 2,
            'Fade': 1
        }
        return [
            mpf.make_addplot(
                self.df[Col.Ind.MFacI.Status.name].map(status_numerical_map),
                type='line', panel=plotter_args['new_panel_num'],
                label='MarketFacIndex'
            )
        ]
